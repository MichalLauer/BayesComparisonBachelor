Další populární software pro generování vzorků z posteriorního rozdělení pomocí
Gibbsova vzorkování je JAGS (*Just Another Gibbs Sampler*), který byl vytvořen v roce 2023 profesorem Martynem
Plummerem. JAGS si zakládá na softwaru a syntaxy BUGS, od kterého se však liší několika
podstatnými změnani, díky kterým je aktivně vyvíjen a jeho vývoj je mnohem
flexibilnější. \parencite{DepaoliEtAl2016_JustAnotherGibbs} uvádí, že je JAGS v
porovnání s BUGS *\enquote{více rozšiřitelný, flexibilní a uživatelsky přívětivý než software BUGS}*.

Primárním důvodem tohoto tvrzení je jazyk, ve kterém je JAGS napsaný. Oproti
BUGS, který používá programovací jazyk Fortran, je zdrojový kód pro JAGS napsán
v jazyce C++. Díky tomu lze JAGS používat na jiných[^jags-os] platformách
než je operační systém Windows, na kterém je verze WinBUGS závislá. Tato 
flexibilita umožňuje i jednodušší vývoj, který není závislý na platformě a
chyby nebo rozšíření lze psát i na jiných[^jags-oos] platformách. Větší
rozříšenost jazyku C++ také zvětšuje počet potencionálních vývojářů
\parencite{DepaoliEtAl2016_JustAnotherGibbs}.

[^jags-os]: Autoři \parencite{DepaoliEtAl2016_JustAnotherGibbs} zmiňují primárně operační systémy Windows, Linux, OS X a UNIX.

[^jags-oos]: Teoreticky lze vyvíjet WinBUGS i na jiném operačním systému, ale 
je nutné k tomu používat externí nástroje, které dokáží systém Windows emulovat.

JAGS také nabízí možnost vytvoření a přidání vlastních modulů, které lze
následně použít při generování vzorků. Rozšířit JAGS lze pomocí jiných
rozdělení, funkcí a vzorkovačů. Oproti BUGS je nástroj JAGS vyvinut bez grafického
rozhrání a ovládá se pomocí příkazového řádku; primárně však k ovládání slouží
různé balíčky v programovacích jazycích R nebo Python. Syntaxe pro tvoření
Bayesovských modelů je založená na formátu BUGS a v jednoduchých případech je
identická
\parencite{DepaoliEtAl2016_JustAnotherGibbs}.

Pro generování vzorků pomocí softwaru JAGS byl vytvořen balíček rjags 
\parencite{Plummer2023_RjagsBayesianGraphical}. Oproti balíčku R2WinBUGS se
v jazyce R pracuje s dvěma hlavními objekty:

- objekt, který reprezentuje kompilovaný model, a
- objekt, ve kterém jsou uložené vygenerované vzorky.

Díky tomu, že je JAGS ovládán pomocí příkazové řádky, lze s modelem pracovat
i bez spouštění externích programů a uživatel má mnohem větši kontrolu při
tvoření modelu a následném generování vzorků. Pomocí funkcí lze jednoduše
znovu generovat další vzorky ze stejného stavu, ve kterém řetězec skončil
\parencite{DepaoliEtAl2016_JustAnotherGibbs}.

Druhým populárním balíčkem, který byl pro JAGS a prostředí R vytvořen, je 
runjags \parencite{Denwood2016_RunjagsPackageProviding}. Jeho sílá spočívá v tom,
že nabízí komplexnější nástroje k tomu, jak generovat vzorky. Balíček zvládné
paralelní generování, díky kterému lze dosáhnout aproximace posteriorního 
rozdělení rychleji a efektivněji. Při generování lze také automaticky kontrolovat
kvalitu konvergence a části, které nejsou kvalitní, umí nahradit.
Balíček také nabízí funkce, které dokáží porovnat generované vzorky z dvou
různých JAGS modelů a navzájem je porovnat
\parencite{DepaoliEtAl2016_JustAnotherGibbs}.

Třetí populární balíček pro práci se softwarem JAGS nese názevm R2jags 
\parencite{SuYajima2024_R2jagsUsingRun}. Název napovídá, že jeho cílem
je vytvořit funkce, které budou velmi podobné funkcím z balíčku R2WinBUGS
pro ovládání softwaru BUGS. Díky podobnému prostředí, avšak velmi odlišnému
nástroji, dokáží JAGS ovládat i uživatelé, kteří znají pouze práci s BUGS.
Balíček také nabízí např. paralelizaci, automatickou kontrolu konvergence
nebo dynamické generování vzorku až do uspokojivého stavu
\parencite{DepaoliEtAl2016_JustAnotherGibbs}.

Všechny tři nástroje vrací generované vzorky v objektu, který má třídu
`mcmc.list`, se kterým dokáže pracovat balíček coda (CODA, *Convergence
Diagnosis and Output Analysis*)
\parencite{PlummerEtAl2006_CODAConvergenceDiagnosis}. coda obsahuje funkce,
které dokáží vypočítat mnoho statistik, které se týkají kvality konvergence,
posteriorních rozdělení nebo jiných diagnostických statistik. K většině z nich
dokáže vytvořit také obrázek v základní R grafice. Nástroj je sice připravený
hlavně pro software JAGS, ale obsahuje funkci `as.mcmc.list`, pomocí které lze
konvertovat BUGS výstup na objekt, který už je s balíčkem coda kompatibilní.
Výhody a diagnostiky z balíčku coda lze tedy uplatnit i na vzorky,
které jsou generovány softwarem BUGS.

Kromě již zmíněných balíčků, které slouží pro obecné generování vzorků, existuje
i několik balíčků, které jsou vytvořené ke specifickým problémům a na pozadí
využívají právě JAGS. Jsou to například balíčku blavaan 
\parencite{MerkleRosseel2018_BlavaanBayesianStructural}
pro analýzu latentních proměnných, blme 
\parencite{ChungEtAl2013_NondegeneratePenalizedLikelihood}
pro pokročilou lineární regresi nebo bayescount 
\parencite{Denwood2023_BayescountPowerCalculations} pro jednoduchou
analýzu dat s diskrétními číselnými proměnnými
\parencite{DepaoliEtAl2016_JustAnotherGibbs}.

#### Balíček {rjags}

Tvorba modelu

```{r jags}
#| results: hide
set.seed(26)
x <- rbinom(10, 1, 0.6)

jags.model <- rjags::jags.model(
    file = "./kapitoly/modely/rjags.txt", # Model
    data = list(
        N     = length(x), # Počet pozorování
        x     = x,         # Vstupní data
        alpha = 0.01,      # Hodnota parametru alpha
        beta  = 0.01       # Hodnota parametru beta
    ),
    # Počáteční hodnoty
    inits = list(
        p = 0.5,
        .RNG.name = "base::Super-Duper", # Generování náhodných čísel
        .RNG.seed = 684                  # Seed
    ),
    n.chains = 2,  # Počet chainů
    n.adapt  = 500 # Adaptační doba
)
```

Burn-in generování, je to pro každý chainu.

```{r }
rjags:::update.jags(object = jags.model, # Model
                    n.iter = 1000, # Počet burn-in iterací
                    progress.bar = "none")
```

Generování vzorků z každého chainu.

```{r }
rjags.samples <- rjags::coda.samples(
    model = jags.model,   # Model, pomocí kterého generovat
    variable.names = c("p"), # Proměnná, kterou sledovat
    n.iter = 5000,        # Kolik vzorků z každého chainu generovat
    thin = 1,
    quiet = TRUE
)

summary(rjags.samples)
```

Základní plot
